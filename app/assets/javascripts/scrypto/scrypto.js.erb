//= require ./sjcl
//= require ./base64

(function( $ ) {	
	$(document).ready( function() {
		$(".scrypto-entropy").each( function() {
			var crypto = new $.fn.scrypto
			
			$(this).html("<span>Entropy: </span><span id='entropy'></span>")
			
			$(window).bind('mousemove', crypto.collect_entropy)
			sjcl.random.startCollectors()
		})
		
		$(".scrypto-key-generator").each( function() {
			var crypto = new $.fn.scrypto
			
			$($(this).children(".scrypto")[0]).html("" + 
				"<input type='hidden' id='owner_id' name='key_ring[owner_id]' />" +
				"<input type='hidden' id='owner_type' name='key_ring[owner_type]' />" +
				"<input type='hidden' id='secured_decryption' name='key_ring[secured_decryption]' />" +
				"<input type='hidden' id='encryption' name='key_ring[encryption]' />" +
				"<input type='hidden' id='secured_signing' name='key_ring[secured_signing]' />" +
				"<input type='hidden' id='verification' name='key_ring[verification]' />" +
				"<label for='scrypto-passphrase'>Passphrase</label><br>" +
				"<input id='scrypto-passphrase' type='password' />")
			
			$(this).bind('submit', function (event) {			
				var k = crypto.generate_keys()
				k = crypto.encrypt_keys($("#scrypto-passphrase").val(), k)
				
				$("#secured_decryption").val(Base64.encode(k.encryption.sec))
				$("#encryption").val(Base64.encode(JSON.stringify(k.encryption.pub)))
				$("#secured_signing").val(Base64.encode(k.signing.sec))
				$("#verification").val(Base64.encode(JSON.stringify(k.signing.pub)))

				return true
			})
		})
		
		$("form .scrypto").each( function() {
			var crypto = new $.fn.scrypto
			var form = $(this)
			
			var public_keys = {}
			
			try {
				form.bind('submit', function(event) {
					if(!parent_form.recipients) {
						return false
					}
					
					var messages = crypto.encrypt_fields(form.recipients, 
						form.passphrase, 
						[field.val()], 
						form.sender_key_ring)

					field.val(Base64.encode(JSON.stringify(messages)))
					return true
				})
			} catch (e) {
				console.log(e)
				return false
			}
		})
	})
		
	$.fn.scrypto = function() {"use strict"
		if(!(this instanceof $.fn.scrypto))
			throw new Error("Constructor called as a function")
	
		var crypto = this
		
		this.collect_entropy = function() {
			var progress = sjcl.random.getProgress(10)
	
			if(progress === undefined || progress == 1) {
				$("#entropy").text("100%")
				sjcl.random.stopCollectors()
				$(window).unbind('mousemove', crypto.collect_entropy)
			} else {
				var percentage = progress * 100;
				$("#entropy").text(percentage.toFixed(0) + "%")
			}
		}
		
		/**
		 * passphrase and encrypted_private_key should be submitted as they exist in their
		 * respective input fields. messages is a list of encrypted messages from the server and
		 * message_keys is an object mapping each message id to its corresponding asymmetrically
		 * encrypted symmetric key
		 **/
		this.decrypt_messages = function(passphrase, message_keys) {
			if(!passphrase || !message_keys)
				throw new Error("Invalid argument(s)")
	
			for(var i = 0; i < message_keys.length; i++) {
				var pvk = JSON.parse(sjcl.decrypt(passphrase, message_keys[i].details.recipient.encrypted_private_key))
				var bn = sjcl.bn.fromBits(pvk.exponent)
				var sec = new sjcl.ecc.elGamal.secretKey(pvk.curve, sjcl.ecc.curves['c' + pvk.curve], bn)
	
				var sym = JSON.parse(sjcl.decrypt(sec, message_keys[i].encrypted_key))
				var message = sjcl.decrypt(sym, message_keys[i].details.message.body)
				message_keys[i].details.message.body = message
			}
	
			return message_keys
		}
	
		this.verify_messages = function(message_keys) {
			if(!message_keys)
				throw new Error("Invalid argument(s)")
	
			for(var i = 0; i < message_keys.length; i++) {
				var json = JSON.parse(message_keys[i].details.sender.verification_key)
				var point = sjcl.ecc.curves['c' + json.curve].fromBits(json.point)
				var sgk = new sjcl.ecc.ecdsa.publicKey(json.curve, point.curve, point)
				var hash = sjcl.hash.sha256.hash(message_keys[i].details.message.body)
				message_keys[i].details.message.verified = sgk.verify(hash, JSON.parse(message_keys[i].details.message.signature))
			}
	
			return message_keys
		}
	
		this.generate_keys = function() {
			var ekp = sjcl.ecc.elGamal.generateKeys(384, 10)
			var skp = sjcl.ecc.ecdsa.generateKeys(384, 10)
	
			return {
				"encryption" : {
					"pub" : ekp.pub.serialize(),
					"sec" : ekp.sec.serialize()
				},
				"signing" : {
					"pub" : skp.pub.serialize(),
					"sec" : skp.sec.serialize()
				},
				"secure" : false
			}
		}
	
		this.encrypt_keys = function(passphrase, keys) {
			if(!passphrase || !keys)
				throw new Error("Invalid argument(s)")
	
			keys.encryption.sec = sjcl.encrypt(passphrase, JSON.stringify(keys.encryption.sec))
			keys.signing.sec = sjcl.encrypt(passphrase, JSON.stringify(keys.signing.sec))
			keys.secure = true
	
			return keys
		}
		
		/*
		 * recipient_ids: a comma separated list of owner_ids (e.g., "7,11,3,4")
		 * fields: an object mapping field name to field content (e.g., "{ 'body': 'some text', 'subject': 'a subject' }")
		 */
		this.encrypt_fields = function(recipient_ids, fields) {
			var public_keys = this.get_public_keys(recipient_ids)
			
			var shared_key
			
			var recipient_message_keys = { }
			
			for(var id in public_keys) {
				if(!public_keys.hasOwnProperty(id)) { continue }
				
				if(!shared_key) {
					shared_key = public_keys[id].kem(10).key
				}
				
				recipient_message_keys[id] = sjcl.encrypt(public_keys[id], JSON.stringify(shared_key))
			}
			
			for(var field_name in fields) {
				fields[field_name] = sjcl.encrypt(shared_key, fields[field_name])
			}
	
			return {
				"recipient_message_keys" : recipient_message_keys,
				"encrypted_fields" : fields
			}
		}
	
		this.get_verification_keys = function(person_ids) {
			var verification_keys = {}
	
			$.ajax({
				url : "/key_ring?person_ids=" + person_ids,
				async : false,
				dataType : "json",
				success : function(data) {
					var json = JSON.parse(data.key_ring.public_verification_key)
					var point = sjcl.ecc.curves['c' + json.curve].fromBits(json.point)
					verification_keys[contact_id] = new sjcl.ecc.ecdsa.publicKey(json.curve, point.curve, point)
				}
			})
	
			return verification_keys
		}
	
		this.get_public_keys = function(owner_ids) {
			var public_keys = {}

			$.ajax({
			    url : "/scrypto/public_keys.json?owner_ids=" + owner_ids,
			    async : false,
			    dataType : "json",
			    success : function(keys) {
					for(var owner in keys) {
			        	var json = JSON.parse(Base64.decode(keys[owner]))
						var point = sjcl.ecc.curves['c' + json.curve].fromBits(json.point)
						public_keys[owner] = new sjcl.ecc.elGamal.publicKey(json.curve, point.curve, point)
					}
			    }
			})
	
			return public_keys
		}
	
		this.decrypt_signing_key = function(passphrase, encrypted_signing_key) {
			var epks = sjcl.decrypt(passphrase, encrypted_signing_key)
			var spk = JSON.parse(epks)
	
			var bignum = sjcl.bn.fromBits(spk.exponent)
			var signing_key = new sjcl.ecc.ecdsa.secretKey(spk.curve, sjcl.ecc.curves['c' + spk.curve], bignum)
	
			return signing_key
		}
	};
})( jQuery );
