//= require ./sjcl
//= require ./base64

(function( $ ) {	
	$(document).ready( function() {
		var crypto = new $.fn.scrypto		
		crypto.attach("html")		
	})
		
	$.fn.scrypto = function() {"use strict"
		if(!(this instanceof $.fn.scrypto))
			throw new Error("Constructor called as a function")
	
		var crypto = this
		
		this.attach = function (parent) {
			$(parent + " form.scrypto").each( function() {
				var form = $(this)
		
				var public_keys = {}
				
				try {
					form.bind('submit', function(event) {
						var progress = sjcl.random.getProgress(10)
		
						if(progress !== undefined && progress != 1) {
							alert("insufficient entropy")
							return false
						}
						
						if($(parent + " .scrypto-output").length == 0) {
							alert("no output field")
							return false
						}
						
						var fields = { }
						
						form.find(".scrypto-encrypt").each( function() {
							fields[$(this).attr("id")] = $(this).val()
						})
						
						if($(parent + " .scrypto-lookup").length > 0) {
							var lookup_url = $(parent + " .scrypto-lookup").first().attr("lookup-url")
							var query = $(parent + " .scrypto-lookup").first().val()
							
							var recipients =  crypto.get_recipient_ids(lookup_url, query)
							
							if(form.attr("data-scrypto-sender") != undefined) {
								recipients = recipients + "," + form.attr("data-scrypto-sender")
							}
							
							form.attr("data-scrypto-recipients", recipients)				
						}
						
						if(!form.attr("data-scrypto-recipients")) {
							alert("no recipients")
							return false
						}
						
						var message = crypto.encrypt_fields(form.attr("data-scrypto-recipients"), fields)
	
						$(parent + " .scrypto-output").first().val(Base64.encode(JSON.stringify(message)))
	
						return true
					})
				} catch (e) {
					console.log(e)
					return false
				}
			})
			
			$(parent + " .scrypto-passphrase").each( function() {
				$(this).html(	"<label for='scrypto-passphrase'>Passphrase</label>" +
								"<input id='scrypto-passphrase' type='password' />")
				
				if($(parent + " .scrypto-decrypt").length > 0) {
					var key_attribute = $(this).attr("data-scrypto-key-attribute")
					
					$(this).html($(this).html() + "<a href='#' id='scrypto-decrypt'>Decrypt</a>")
					
					$(parent + " #scrypto-decrypt").bind('click', function() {
						var keys = JSON.parse(window[key_attribute])
						var decryption_key = crypto.decrypt_decryption_key($("#scrypto-passphrase").val(), Base64.decode(keys.decryption))
						
						$(parent + " .scrypto-decrypt").each( function() {
							var message = JSON.parse(Base64.decode($(this).text()))
							var accessible_message_key = sjcl.decrypt(decryption_key, message.recipient_message_keys[keys.id])
							$(this).text(sjcl.decrypt(JSON.parse(accessible_message_key), message.encrypted_fields.message_body))
						})
					})
				}
			})
			
			$(parent + " .scrypto-entropy").each( function() {
				$(this).html("<span>Entropy: </span><span id='entropy'>0%</span>")
				
				$(window).bind('mousemove', crypto.collect_entropy)
				sjcl.random.startCollectors()
			})
			
			$(parent + " .scrypto-key-fields").each( function() {
				$(this).html("" + 
					"<input type='hidden' id='secured_decryption' name='key_ring[secured_decryption]' />" +
					"<input type='hidden' id='encryption' name='key_ring[encryption]' />" +
					"<input type='hidden' id='secured_signing' name='key_ring[secured_signing]' />" +
					"<input type='hidden' id='verification' name='key_ring[verification]' />")
				
				var form = $(this).parents("form")
				form.bind('submit', function (event) {	
					if(form.attr("data-store-passphrase")) {
						if(localStorage["scrypto-passphrases"] == null) {
							var passphrases = {}
							localStorage["scrypto-passphrases"] = JSON.stringify(passphrases)
						}
						
						var user = form.attr("data-user-id")
						var passphrases = JSON.parse(localStorage.getItem("scrypto-passphrases"))
						passphrases[user] = $("#scrypto-passphrase").val()
						
						localStorage["scrypto-passphrases"] = JSON.stringify(passphrases)
					}
					
					var k = crypto.generate_keys()
					k = crypto.encrypt_keys($("#scrypto-passphrase").val(), k)
					
					$("#secured_decryption").val(Base64.encode(k.encryption.sec))
					$("#encryption").val(Base64.encode(JSON.stringify(k.encryption.pub)))
					$("#secured_signing").val(Base64.encode(k.signing.sec))
					$("#verification").val(Base64.encode(JSON.stringify(k.signing.pub)))
	
					return true
				})
			})
		}
		
		this.collect_entropy = function() {
			var progress = sjcl.random.getProgress(10)
	
			if(progress === undefined || progress == 1) {
				$("#entropy").text("100%")
				sjcl.random.stopCollectors()
				$(window).unbind('mousemove', crypto.collect_entropy)
			} else {
				var percentage = progress * 100;
				$("#entropy").text(percentage.toFixed(0) + "%")
			}
		}
		
		this.get_recipient_ids = function(lookup_url, query) {
			var recipient_ids = ""
			
			$.ajax({
				url : lookup_url + query,
				async : false,
				dataType : "json",
				success : function(data) {
					for(var i = 0; i < data.length; i++) {
						if(!recipient_ids) {
							recipient_ids = data[i]
						} else {
							recipient_ids = recipient_ids + "," + data[i]
						}
					}
				}
			})
			
			return recipient_ids
		}
		
		/**
		 * passphrase and encrypted_private_key should be submitted as they exist in their
		 * respective input fields. messages is a list of encrypted messages from the server and
		 * message_keys is an object mapping each message id to its corresponding asymmetrically
		 * encrypted symmetric key
		 **/
		this.decrypt_messages = function(passphrase, message_keys) {
			if(!passphrase || !message_keys)
				throw new Error("Invalid argument(s)")
	
			for(var i = 0; i < message_keys.length; i++) {
				var pvk = JSON.parse(sjcl.decrypt(passphrase, message_keys[i].details.recipient.encrypted_private_key))
				var bn = sjcl.bn.fromBits(pvk.exponent)
				var sec = new sjcl.ecc.elGamal.secretKey(pvk.curve, sjcl.ecc.curves['c' + pvk.curve], bn)
	
				var sym = JSON.parse(sjcl.decrypt(sec, message_keys[i].encrypted_key))
				var message = sjcl.decrypt(sym, message_keys[i].details.message.body)
				message_keys[i].details.message.body = message
			}
	
			return message_keys
		}
	
		this.verify_messages = function(message_keys) {
			if(!message_keys)
				throw new Error("Invalid argument(s)")
	
			for(var i = 0; i < message_keys.length; i++) {
				var json = JSON.parse(message_keys[i].details.sender.verification_key)
				var point = sjcl.ecc.curves['c' + json.curve].fromBits(json.point)
				var sgk = new sjcl.ecc.ecdsa.publicKey(json.curve, point.curve, point)
				var hash = sjcl.hash.sha256.hash(message_keys[i].details.message.body)
				message_keys[i].details.message.verified = sgk.verify(hash, JSON.parse(message_keys[i].details.message.signature))
			}
	
			return message_keys
		}
	
		this.generate_keys = function() {
			var ekp = sjcl.ecc.elGamal.generateKeys(384, 10)
			var skp = sjcl.ecc.ecdsa.generateKeys(384, 10)
	
			return {
				"encryption" : {
					"pub" : ekp.pub.serialize(),
					"sec" : ekp.sec.serialize()
				},
				"signing" : {
					"pub" : skp.pub.serialize(),
					"sec" : skp.sec.serialize()
				},
				"secure" : false
			}
		}
	
		this.encrypt_keys = function(passphrase, keys) {
			if(!passphrase || !keys)
				throw new Error("Invalid argument(s)")
	
			keys.encryption.sec = sjcl.encrypt(passphrase, JSON.stringify(keys.encryption.sec))
			keys.signing.sec = sjcl.encrypt(passphrase, JSON.stringify(keys.signing.sec))
			keys.secure = true
	
			return keys
		}
		
		/*
		 * recipient_ids: a comma separated list of owner_ids (e.g., "7,11,3,4")
		 * fields: an object mapping field name to field content (e.g., "{ 'body': 'some text', 'subject': 'a subject' }")
		 */
		this.encrypt_fields = function(recipient_ids, fields) {
			var public_keys = this.get_public_keys(recipient_ids)
			
			var shared_key
			
			var recipient_message_keys = { }
			
			for(var id in public_keys) {
				if(!public_keys.hasOwnProperty(id)) { continue }
				
				if(!shared_key) {
					shared_key = public_keys[id].kem(10).key
				}
				
				recipient_message_keys[id] = sjcl.encrypt(public_keys[id], JSON.stringify(shared_key))
			}
			
			for(var field_name in fields) {
				fields[field_name] = sjcl.encrypt(shared_key, fields[field_name])
			}
	
			return {
				"recipient_message_keys" : recipient_message_keys,
				"encrypted_fields" : fields
			}
		}
	
		this.get_verification_keys = function(person_ids) {
			var verification_keys = {}
	
			$.ajax({
				url : "/key_ring?person_ids=" + person_ids,
				async : false,
				dataType : "json",
				success : function(data) {
					var json = JSON.parse(data.key_ring.public_verification_key)
					var point = sjcl.ecc.curves['c' + json.curve].fromBits(json.point)
					verification_keys[contact_id] = new sjcl.ecc.ecdsa.publicKey(json.curve, point.curve, point)
				}
			})
	
			return verification_keys
		}
	
		this.get_public_keys = function(owner_ids) {
			var public_keys = {}

			$.ajax({
			    url : "/scrypto/public_keys.json?owner_ids=" + owner_ids,
			    async : false,
			    dataType : "json",
			    success : function(keys) {
					for(var owner in keys) {
			        	var json = JSON.parse(Base64.decode(keys[owner]))
						var point = sjcl.ecc.curves['c' + json.curve].fromBits(json.point)
						public_keys[owner] = new sjcl.ecc.elGamal.publicKey(json.curve, point.curve, point)
					}
			    }
			})
	
			return public_keys
		}
	
		this.decrypt_signing_key = function(passphrase, encrypted_signing_key) {
			var epks = sjcl.decrypt(passphrase, encrypted_signing_key)
			var spk = JSON.parse(epks)
	
			var bignum = sjcl.bn.fromBits(spk.exponent)
			var signing_key = new sjcl.ecc.ecdsa.secretKey(spk.curve, sjcl.ecc.curves['c' + spk.curve], bignum)
	
			return signing_key
		}
		
		this.decrypt_decryption_key = function(passphrase, encrypted_decryption_key) {
			var epks = sjcl.decrypt(passphrase, encrypted_decryption_key)
			var spk = JSON.parse(epks)
	
			var bignum = sjcl.bn.fromBits(spk.exponent)
			var decryption_key = new sjcl.ecc.elGamal.secretKey(spk.curve, sjcl.ecc.curves['c' + spk.curve], bignum)
	
			return decryption_key
		}
	};
})( jQuery );
